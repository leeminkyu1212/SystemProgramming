//////////
메모리 누수

Memory leak
• 메모리가 누수 된다면 어떤 일이 발생할까?
->메모리 자원이 부족해진다.
→ 시스템의 성능이 느려지거나 동작하지 않을 수 있다

• OS가 재부팅이 되면, 시스템에 존재하던 모든 프로세스와 스레드등의 메모리 공간이 해제된다.
-> 재부팅을 할수 없는 시스템이라면?

메모리 누수를 발생시키는 요인
매우 많은 요인들이 메모리 누수를 발생시킨다.
• 동적으로 할당된 포인터 변수를 재할당 할 때
• 파일을 열고 닫지 않을 때
• 동적 할당 후 메모리 해제를 하지 않을 때
• 상호 참조 등등
물론, 해제 하지 않아도 별 문제 없었다고 느낄 수 있다

메모리 누수 해결책

1. 코드를 잘 쓰자
   • 할당 했으면 해제하자.
   • 열었으면 닫자.
   • 항상 세트로 코드를 작성하는 습관을 가진다.
2. RAII 패턴 사용 – C++
   • Resource Acquisition Is Intialization 디자인 패턴
3. 스마트 포인터 – C++
4. 코드 리뷰
5. 테스트와 디버깅

close(), free(), del ~ 등등 해제를 반드시 해줘 메모리 누수를 방지하자.

/////////////////////////////
process

프로세스는 2진수로 이뤄진 명령어 집합이다? ->X
프로그램: 이진수로 이루어진 명령어 집합이다. ->O
프로세서:cpu
프로그램이 실행되면 HDD 에서 메모리로 로드 된다->프로세스

하나의 OS에는 여러 개의 프로세스가 존재할 수 있다

펌웨어에서는 1개의 프로세스가 존재한다.

각각의 프로세스는 독립적인 메모리 공간을 가질 수 있다

프로세스
리눅스를 부팅하면 최초의 프로세스가 존재한다.
• 각 프로세스는 ID가 존재한다.
• Process ID 라고 부르며, 줄여서 PID 라고 한다.
PID 1 번은 최초의 프로세스 이다.

무한 # 찍기 프로그램 제작해보기
• 3초에 # 하나씩 출력하는 프로그램 작성
• 빌드 후 run
• 글씨가 안 나온다면 버퍼 플러시 명령어 하나더 추가
• 프로그램 시작지점에 setbuf 추가
• sleep, usleep 사용할 때 화면에 안 찍힐 경우가 있는데,
이 때 버퍼를 비우고 시작해야 (stdout 은 터미널을 의미)
• 프로그램 이름
• findme

Process 확인 방법
• 방법 1 : ps –ef
• e : 커널프로세스를 제외한 모든 프로세스 출력
• f : Full Format 으로 보여준다. PID 등 모든 정보 출력
• 방법 2 : top
• 방법 3 : htop(f4로 검색)
findme App을 찾아보자.

1)프로그램 실행 -> # 찍기 2) ps -ef 로 PID 확인(2284) 3) /proc/[pid]/maps 이동해서 PID로 디렉토리 들어가기

//////////////////////////////
프로세스 구성

각 프로세스는 연속적인 메모리 공간을 사용하고 있다고 착각하도록 한다.
• 실제 물리적 Address와 다르다.
장점
• 메모리 파편화에 대한 구현 쉬워짐
• 저장장치를 메모리인양 사용가능 (swap 영역)
• 더 큰 메모리 사용

//////////////////
context switching

context-> 프로세스 안의 어떤 상태(정보)를 바꾼다.->일이 발생한다.
cpu는 기본적으로 하나의 프로세스만 실행한다
매우 빠르게 여러 프로세스를 실행하여 (context switching 발생)->
동시 동작하는 것처럼 보인다.

Process 스케쥴링

하나의 Core는 여러개 프로세스을 순환하면서 수행
• 특정 시간마다 번갈아가면서 수행한다.
• 대체로 Round Robin 으로 동작하며 OS 마다의 계산 공식에 의해 우선순위가 변경된다.

프로세스 간 메모리는 독립적으로 운영을 함
• 각자의 가상 메모리 주소 영역을 갖는다.

만약 어떤 프로그램이 다른 프로그램에게 값을 전달하고 싶다면
• 프로세스끼리 값을 주고 받는 것을 IPC (InterProcess Communication) 이라고 한다.
• IPC 방법
• 프로세스 끼리 공유하는 메모리를 쓰는 방법
• 커널의 도움을 받아 대신 전달해주는 방법

PCB (Process Control Block)
• 커널이 프로세스를 제어하기 위한 정보를 저장하는 블럭
• 프로세스 Descriptor 라고도 한다.
• 저장정보
프로세스 상태 (State), PID등 프로세스에 대한 다양한 정보들을 보관

갑작스럽게 시간이 다 되어서 다음 프로세스를 수행해야 할 때
• Register에 값들을 저장하며 Process 수행 중인데, 갑자기 사용시간이 다 되었다면?
• 레지스터를 어딘가에 백업이 필요하다.
레지스터들을 PCB 에 저장한다.
• Process 전환시 반드시 해야하는 작업
각 Process 마다 사용중이던 레지스터 값이 존재
• PCB 내부에 저장
다음 Process로 전환 후, PCB에 저장된 레지스터를
Core로 가져온다.

cpu는 프로세스에 가서
->pcb를 보고 어디 까지 작업했는지 확인한뒤
->일을 한다
-> 다른 프로세스로 가라고 (스케줄러) 가 시킨다.
-> 하던 작업을 정리해서 pcb에 기록을 한다.

context switching이 일어난다 ==비용이 발생한다 -> 안좋다

////////////////////////////////////////
process State

Linux Process State Machine
다섯개의 Process의 State Machine
R: Running/Runnable
S: Interruptible Sleep
D: Uninterruptible Sleep
T: Stopped
Z: Zombie

/////////////////////////////
Process State

Context Switching 으로 선택된 하나의 프로세스만 수행이 된다.
• 이 상태를 running state에 있다고 한다.
• 나머지 프로세스들은 Runnable (Ready) 상태에 있다

Run Queue
• 우선순위 값에 따라 스케쥴러가 먼저 수행할 것을 결정을 지을 수 있는 후보들이 존재하는 큐
• Run Queue에서 탈출하는 경우
→ I/O 응답 (Disk) 대기하거나 종료 신호 발생 시 탈출하며 다른 State가 된다.

Uninterruptible Sleep
깨울 수 없는 Sleep
• 특정한 System Call 호출시 발생하는 State (잘 안쓰임)
• mkdir 사용시 응답이 올 때 까지 멈출 수 없는 잠을 잔다.

Interruptible Sleep

그 외, 일반적인 Sleep
• 어떤 동작을 기다리고 있을 때 / Sleep 사용시 진입하는 State
• sleep System Call 사용시
• I/O 처리를 한 후, 응답이 오기 까지 대기중
• Timer 사용시 등

sleep System Call 호출하면 Sleep 상태가 됨을 확인 가능

```
Stop state
Ctrl + Z 눌렀을 때 진입
• vi 실행시 Ctrl + Z 누르면 SIGSTOP 이라는 Signal이 발생함=>종료
Ctrl + C => SIGINT(interrupt) =>종료
```

[실습] Signal 수동으로보내기
HTOP 기능을 이용하여 SIGSTOP 시그널 전송
• 숫자를 반복시키는 프로그램을 제작하자
• printf로 출력
• 글씨가 안나온다면
setbuf(stdout, NULL);
• SIGSTOP으로 멈춘다.
• htop에서 T 상태를 확인한다.
• SIGCONT로 다시 동작시키자.
• SIGKILL 으로 종료시키자

-->htop, 명령어로 pid 가져오는법 알기

//////////////////////////////////
Signal이란

Signal
• Thread / Process에게 정보를 전달하는 신호
• Linux 에서는 최대 256개 신호 까지 전달될 수 있도록 함
• 시그널 종류 : $kill –l (엘)
• 단순 정보를 보낼 때 사용한다.
• 더 많은 정보 (Message Level)로 보내고 싶다면, Socket, IPC 등 사용

Interrupt 인터럽트
CPU가 동작 중, 하던 일을 멈추고 처리하도록 하는 것
• 전화벨 소리가 울리면 = 인터럽트 발생
• 전화 받고 다시 하던 일을 한다.
• 일하고 있는데 누군가 부르면 = 업무 인터럽트 발생
• 대응 후 돌아와서 다시 일한다.
• 게임하고 있는데 와이프의 기척이 느껴지면 = 인터럽트 발생
• 와이프를 안심시키고, 다시 돌아와서 게임한다.
Interrupt 발생시 예약된 함수가 동작
• 콜백처럼 예약된 함수가 동작된다

[중요] ISR과 인터럽트 핸들러

ISR (Interrupt Service Routine)
• 인터럽트에 대응하여 호출되는 코드 (주로 함수)
• 인터럽트 핸들러 라고 부르며, ISR / Handler 모두 자주 쓰이는 용어
->버튼이 누르면, 인터럽트가 발생하여 하던일을 즉시 멈추고, ISR이 동작된다.
Handler에서 버튼에 대한 처리 후, 원래 하던 동작으로 돌아간다.


Interrupt 종류

임베디드에서 버튼 누르기
• GPIO PIN 에 전기의 흐름이 바뀌면서 HW Interrupt가 발생
• ISR 이 동작함
리눅스의 Signal 발생
• SW Interrupt가 발생하여 하던 일을 멈추고
지정된 Handler 함수가 즉시 호출 됨
• 핸들러를 지정해주지 않으면, 커널 내부에서 Default 동작을 수행함
